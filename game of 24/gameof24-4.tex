\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{mdframed} 

\geometry{a4paper, margin=1in}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{Gray}{gray}{0.95}

\lstdefinestyle{code}{
    language = C,					
    basicstyle = \small\ttfamily,	
    numbers = left,					
    numberstyle = \footnotesize,	
    frame = tb,				      
    framextopmargin=.75mm,         
    framexbottommargin=.75mm,      
    framexleftmargin=2mm,          
    framexrightmargin=2mm,         
    tabsize = 3,					
    breaklines = true,             
    columns = fullflexible,			
    showstringspaces = false,
    backgroundcolor = \color{Gray}
}

\lstset{style=code}


\newmdenv[
  backgroundcolor=gray!10,
  linecolor=black,
  innerleftmargin=10pt,
  innerrightmargin=10pt,
  innertopmargin=10pt,
  innerbottommargin=10pt,
  skipabove=10pt,
  skipbelow=10pt
]{testcase}

\lstset{style=mystyle}

\title{Game of 24}
\author{XueJin Cui (S5876095) \& Jiayi Yang (S6456774)}
\date{October 2025}

\begin{document}

\maketitle

\section{Problem description}
A program is required that determines whether 4 input numbers can form a value of 24, using only addition, subtraction, division and multiplication. If can, determine the process to get the number 24. The 4 input numbers are integers between 1 and 10(inclusive)

\section{Problem analysis}
We interpret the problem as follows:

Given 4 numbers from 1 to 10(inclusive), determine whether there exists a sequence of mathematical calculation ( addition, subtraction, multiplication, division only) and eventually form the number of 24. This interpretation is motivated by the following statements:

\begin{itemize}
    \item Recursion decomposition: Combines 2 numbers by one single mathematical calculation to form a new number in order to reduce the scale of the problem. In the next recursion, these two numbers are deleted from the set, and the new number is added to the set. The process(recursion) repeats until only 1 number remains.
    \item If only 1 number exists, check if it equals to 24. If it is equal to 24, store the corresponding expression and terminate the further operation. Else, go for other new combinations.
\end{itemize}

The termination condition is follow:

\begin{verbatim}
if (there is only 1 remaining number ) {
    if (the remaining number is 24)) ...
}
\end{verbatim}

Among the process, we need to consider about the sequence as well. For multiplication and addition, we only need to consider 1 sequence : x+y=y+x ; x*y=y*x

However, in terms of division and subtraction, there are 2 sequences as x-y not equal to y-x; and x/y not equal to y/x;

The advantage of the algorithm is : is able to track the complete corresponding expression and once obtain the value of 24, return the expression directly and skips the remaining steps.



\section{Program code}
\begin{lstlisting}[style = code, title = 24gamesolver.c]
/* Xuejin Cui & Jiayi Yang written in october 2025*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
void input(double numbers[],char expr[][100]) {

   // Input function to read 4 numbers
   double a;
   printf("Input 4 numbers between 1 and 10 (inclusive):\n");
   for (int i=0;i<4;i++) {
      scanf ("%lf",&a);
      // check validity
      if ((a>=1) && (a<=10)) { 
         numbers[i] = a;
      } else {
         printf("Invalid input.\n");
         i--;
      }
   }

   // Initialize expressions as strings of the numbers
   for (int j=0;j<4;j++) {
      snprintf(expr[j],100,"%.0f",numbers[j]);
   }
}

int isEqual(double a,double b) {
   // Check if two doubles are equal
   return (fabs(a-b)<1e-9);
}

int isPossible(
   int length, double numbers[4],
   char expressions[4][100], char result[100]) {

      double newNumbers[4]; // Temporary array for new numbers
      char newExpressions[4][100]; // Temporary array for new expressions

      // Base case: if only one number left, check if it equals 24
      if (length == 1) {
         if (isEqual(numbers[0],24)) {
            snprintf(result,100,"%s",expressions[0]); //set result
            return 1;
         } else {
            return 0;
         }
      }

      // Use double loops to consider all pairs of numbers
      for (int i=0;i<length;i++) {
         for (int j=i+1;j<length;j++) {

            int index = 0;
            // Fill newNumbers and newExpressions with remaining numbers
            for (int k=0;k<length;k++) {
               if ((k!=i)&&(k!=j)) {
                  newNumbers[index] = numbers[k];
                  snprintf(newExpressions[index],100,"%s",expressions[k]);
                  index++;
               } 
            } 

            //Then try all operations between numbers[i] and numbers[j]

            //For addition and multiplication, we only need to do one order
            //addition:
            newNumbers[index] = numbers[i] + numbers[j]; // store sum
            snprintf (
               newExpressions[index],100,
               "(%s + %s)",expressions[i],expressions[j]);
               // store expression

            //Check if this leads to a solution, if so return 1 and skip rest
            if (isPossible(length-1,newNumbers,newExpressions,result)) {
               return 1;
            }
            
            // The other operation following the same pattern:
            //multiplication:
            newNumbers[index] = numbers[i] * numbers[j];
            snprintf (
               newExpressions[index],100,
               "(%s * %s)",expressions[i],expressions[j]);
            
            if (isPossible(length-1,newNumbers,newExpressions,result)) {
               return 1;
            }
            
            //For subtraction and division, we need to consider both orders
            //subtraction (order i - j):
            newNumbers[index] = numbers[i] - numbers[j];
            snprintf (
               newExpressions[index],100,
               "(%s - %s)",expressions[i],expressions[j]);

            if (isPossible(length-1,newNumbers,newExpressions,result)) {
               return 1;
            }

            //subtraction (order j - i):
            newNumbers[index] = numbers[j] - numbers[i];
            snprintf (
               newExpressions[index],100,
               "(%s - %s)",expressions[j],expressions[i]);

            if (isPossible(length-1,newNumbers,newExpressions,result)) {
               return 1;
            }

            //For division, we also need to ensure the denominator is not zero
            //division (order j / i):
            if (!isEqual(numbers[i],0)) {
               newNumbers[index] = numbers[j] / numbers[i];
               snprintf (
                  newExpressions[index],100,
                  "(%s / %s)",expressions[j],expressions[i]);
               
               if (isPossible(length-1,newNumbers,newExpressions,result)) {
                  return 1;
               }
            }

            //division (order i / j):
            if (!isEqual(numbers[j],0)) {
               newNumbers[index] = numbers[i] / numbers[j];
               snprintf (
                  newExpressions[index],100,
                  "(%s / %s)",expressions[i],expressions[j]);

               if (isPossible(length-1,newNumbers,newExpressions,result)) {
                  return 1;
               }
            }
         }
      }

      return 0;
}

int main(int argc, char *argv[]) {
   double numbers[4];
   char expressions[4][100];
   char result[100];
   input(numbers,expressions);
   if (isPossible(4,numbers,expressions,result)) {
      printf("Solution found: %s = 24\n",result);
   } else {
      printf ("No solution found.\n");
   }
   return 0;
}
\end{lstlisting}

\section{Test results}

\subsection{Test Cases for 24-Point Game}

\begin{testcase}
\textbf{Input:} (normal simple case)\\
8 9 3 4\\
\textbf{Output:}\\
Solution found: ((8 + 9) + (3 + 4)) = 24
\end{testcase}

\begin{testcase}
\textbf{Input:} (case that cannot form the value of 24)\\
1 1 1 1\\
\textbf{Output:}\\
No solution founded.
\end{testcase}

\begin{testcase}
\textbf{Input:} (the case that input contains the boundary)\\
1 10 5 6\\
\textbf{Output:}\\
Solution found: (6 * ((10 - 1) - 5)) = 24
\end{testcase}

\begin{testcase}
\textbf{Input:} (the case that input is out of boundary)\\
11 8 9 1\\
\textbf{Output:}\\
Invalid input.
\end{testcase}

\begin{testcase}
\textbf{Input:} (the complex case that contains decimal)\\
3 8 3 8\\
\textbf{Output:}\\
Solution found: (8 / (3 - (8 / 3))) = 24
\end{testcase}

\section{Evaluation}
As the algorithm uses a recursive structure, the design and implementation of the program is relatively straightforward. The definition of the problem is using the four given numbers to obtain a value of 24 by using the basic mathematical calculation. The core idea of our program is to reduce the number of elements in the set step by step until the number 24 is achieved. This concept is simple and clear.
Under the current rules of 24 game, the program is able to print out the correct result. It considers all possible combinations of 4 numbers. For subtraction and division, specifically, will test 2 possible sequences. 
In our originally program, we used ‘float’ which may produce tiny errors after multiple calculations such as 23.999999 or 24.000001 and we replaced it with ‘double’ in the current program. The precision increases from 7 significant digits to 15–16 significant digits.
Floating-point errors are smaller, making calculations more stable. And by using isEqual(a, b) function with a tolerance of 1e-9, this precision problem can be resolved.
Alternatively, approaches of using iteration with all permutations and dynamic programming would be possible as well. However, iteration approach has a extremely high complexity and need to manage the combinations of calculations manually, While the dynamic programming approach is complicate to implement and need to design data structure. 
In conclusion, We believe that the recursion approach is much more efficient and easy to achieve, and guarantees correct results for all valid inputs.


\end{document}